<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubo FPS Mouse Control P2P</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; cursor: crosshair; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            font-family: sans-serif; background: rgba(0, 0, 0, 0.8);
            padding: 15px; border-radius: 10px; pointer-events: none;
            border: 1px solid #333; z-index: 10;
        }
        #instrucciones {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; text-align: center;
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 10px;
        }
        .status-on { color: #00ff88; }
    </style>
</head>
<body>

<div id="ui">
    <h3 style="margin:0 0 10px 0">Cubo Arena Multi</h3>
    <div>Estado: <span id="status">Conectando...</span></div>
    <div>Jugadores: <span id="count">1</span></div>
    <small style="display:block; margin-top:10px; color: #aaa;">Mover: W, A, S, D | Vista: RATÓN</small>
</div>

<div id="instrucciones">
    <h2>Haz CLIC para jugar</h2>
    <p>(Esc para salir del ratón)</p>
</div>

<script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { joinRoom } from 'https://esm.sh/trystero@0.22.0/nostr';

    // --- CONFIGURACIÓN ---
    const config = { appId: 'cubo-fps-mouse-99' };
    const myColor = Math.floor(Math.random() * 0xffffff);
    let peers = {};

    // --- ESCENA ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a12);
    scene.fog = new THREE.Fog(0x0a0a12, 2, 30);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Un contenedor para la cámara para manejar rotación X e Y por separado
    const cameraGroup = new THREE.Group();
    cameraGroup.add(camera);
    scene.add(cameraGroup);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 2));
    const grid = new THREE.GridHelper(100, 50, 0x00ffff, 0x222222);
    scene.add(grid);

    cameraGroup.position.set(Math.random() * 4, 1, 5);

    // --- CONTROL DEL RATÓN (Pointer Lock) ---
    const inst = document.getElementById('instrucciones');
    
    document.addEventListener('click', () => {
        renderer.domElement.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
        inst.style.display = document.pointerLockElement === renderer.domElement ? 'none' : 'block';
    });

    let pitch = 0; // Rotación arriba/abajo
    let yaw = 0;   // Rotación izquierda/derecha

    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === renderer.domElement) {
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;

            // Limitar rotación arriba/abajo para no dar la vuelta completa
            pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, pitch));

            cameraGroup.rotation.y = yaw;
            camera.rotation.x = pitch;
        }
    });

    // --- RED (P2P) ---
    const room = joinRoom(config, 'sala-raton-1');
    const [sendMove, getMove] = room.makeAction('m');
    const [sendColor, getColor] = room.makeAction('c');

    room.onPeerJoin(peerId => {
        document.getElementById('status').innerText = "En línea";
        document.getElementById('status').className = "status-on";
        sendColor(myColor, peerId);
    });

    room.onPeerLeave(peerId => {
        if (peers[peerId]) {
            scene.remove(peers[peerId]);
            delete peers[peerId];
            updateCount();
        }
    });

    getColor((color, peerId) => {
        if (!peers[peerId]) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshPhongMaterial({ color: color })
            );
            mesh.position.y = 0.5;
            scene.add(mesh);
            peers[peerId] = mesh;
            updateCount();
        }
    });

    getMove((data, peerId) => {
        if (peers[peerId]) {
            peers[peerId].position.set(data.x, data.y, data.z);
            peers[peerId].rotation.y = data.ry;
        }
    });

    function updateCount() {
        document.getElementById('count').innerText = Object.keys(peers).length + 1;
    }

    // --- MOVIMIENTO TECLADO ---
    const keys = {};
    window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
    window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

    function loop() {
        requestAnimationFrame(loop);
        
        let moved = false;
        const speed = 0.15;
        const dir = new THREE.Vector3();
        
        // Obtener dirección frontal basada en la rotación del grupo (yaw)
        const front = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        const side = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

        if (keys['w']) { cameraGroup.position.addScaledVector(front, speed); moved = true; }
        if (keys['s']) { cameraGroup.position.addScaledVector(front, -speed); moved = true; }
        if (keys['a']) { cameraGroup.position.addScaledVector(side, -speed); moved = true; }
        if (keys['d']) { cameraGroup.position.addScaledVector(side, speed); moved = true; }

        if (moved || document.pointerLockElement === renderer.domElement) {
            sendMove({ 
                x: cameraGroup.position.x, 
                y: 0.5, 
                z: cameraGroup.position.z, 
                ry: yaw 
            });
        }

        renderer.render(scene, camera);
    }

    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };

    loop();
</script>
</body>
</html>
